#if defined(__STDC__)
#  if (__STDC_VERSION__ >= 199901L)
#     define _XOPEN_SOURCE 700
#  endif
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include "mpi.h"
#include <stdbool.h>
#include <kdtree_shared.h>
#include <kdtree_mpi_A2A.h>


bool IsPowerOfTwo(int x)
{
  return (x != 0) && ((x & (x - 1)) == 0);
}


void build_kdtree_distributed_A2A(struct kd_node_t * node, struct kd_point_t *points, int N, int ndim, int axis, int level, MPI_Comm comm)
{
  // local rank, size in local communicator
  // global rank, global in MPI_COMM_WORLD
  int rank, N_p, world_rank, world_size;
  MPI_Comm_size(comm, &N_p);
  MPI_Comm_rank(comm, &rank);
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);
  
  if (N==0) {
    printf("ERROR!\n");
    return;
  }
  
  // axis is the splitting dimension from the previous call
  int myaxis = choose_splitting_dimension (ndim, axis);
  // level is the level of depth from the previous call
  int mylevel = level + 1;
  node->axis = myaxis;
  node->level = mylevel;
  
  if ( level == MAX_MPI_LEVEL || N_p < 2 || N < MIN_NUM_OF_POINTS ) {
    node->kid = NULL;
    // For small data let's print the points passed to the serial part
#if defined(DEBUG_POINTS)
    show_array_A2A( points, 0, N, mylevel, 'Z') ;
#endif
    build_kdtree_serial(node, points,  N,  ndim,  axis, mylevel);
    return;
  }
  
  // Package the points in MPI type to be sent around
  MPI_Datatype MPI_kd_point, tmp_type;
  int array_of_blocklengths[] = {ndim};
  MPI_Aint array_of_displacements[] = {0};
  MPI_Datatype array_of_types[] = {MPI_float_t};
  MPI_Aint lb, extent;
  MPI_Type_create_struct(1, array_of_blocklengths, array_of_displacements,
                         array_of_types, &tmp_type);
  MPI_Type_get_extent(tmp_type, &lb, &extent);
  MPI_Type_create_resized(tmp_type, lb, extent, &MPI_kd_point);
  MPI_Type_commit(&MPI_kd_point);
  // Splitting point
  struct kd_point_t * splitting_point;
  // obtained by means of the serial quickselect selecting the N/2-th element
  splitting_point = quickselect(points, N, N/2, myaxis);
  /*
    printf("[level=%d]-(local_size=%d,local_rank=%d)-(world_size=%d,world_rank=%d):{N=%d:[N_l=%d,N_r=%d]} (* axis=%d *) -> median: (%f)\n",
    mylevel, N_p, rank, world_size, world_rank, N, N_l, N_r, myaxis,
    splitting_point->kd_coord[myaxis]);
  */
  // If everything is correct and splitting point exists..
  if (splitting_point) {
    // Simple all to all exchange
    MPI_Alltoall(points, N/N_p, MPI_kd_point, points, N/N_p, MPI_kd_point, comm);
    // We are going to split the communicator
    int new_rank, new_size, color;
    MPI_Comm  new_comm;
    if(rank < N_p/2)
      color=0;
    else
      color=1;
    MPI_Comm_split(comm, color, rank, &new_comm);
    MPI_Comm_size(new_comm, &new_size);
    MPI_Comm_rank(new_comm, &new_rank);
    node->left = NULL;
    node->right = NULL;
    // HERE WE STORE THE POINTER TO THE SPLITTING POINT, NOT THE SPLITTING POINT
    //node->split = splitting_point;
    node->split = NULL;
    // We are in the parallel part, we have only one kid
    node->kid =(struct kd_node_t*) malloc (sizeof(struct kd_node_t));
    // We allocate the memory for the kid here
    build_kdtree_distributed_A2A(node->kid , points,  N, ndim, myaxis, mylevel, new_comm);
  }
  MPI_Type_free(&MPI_kd_point);
  MPI_Type_free(&tmp_type);
  if (comm!=MPI_COMM_WORLD)
    MPI_Comm_free(&comm);
  return ;
}



void clear_A2A(struct kd_node_t *root)
/*
 * This function frees the nodes of the tree
 * NOTE! THIS IS DIFFERENT FROM THE P2P VERSION
 */
{
  if(root==NULL)
    return;
  if(root->kid) {
    clear_A2A(root->kid);
  }
  else {
    clear_A2A(root->left);
    clear_A2A(root->right);
  }
  free(root);
}


void show_array_A2A(const  kd_point *data,
                    const int start,
                    const int end,
                    const int level,
                    const char c)
/*
 * Function to print the points in data from start to end,
 * according to the level in the tree
 */
{
  int global_size, global_rank;
  MPI_Comm_size(MPI_COMM_WORLD, & global_size);
  MPI_Comm_rank(MPI_COMM_WORLD, & global_rank);
  for ( int i = start; i < end; i++ )
    printf("p:[%d](%c){%d} [%.3f, %.3f],\n", level, c, global_rank, data[i].kd_coord[0], data[i].kd_coord[1]);
}


void print_tree_A2A(const struct kd_node_t *node)
/*
 * Function to visualize the tree generated by node, mainly for debugging/checking
 */
{
  if(node==NULL) {return;}
  int rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  if(node->kid==NULL && node->left==NULL && node->right==NULL) {
    printf("C) %d %3d P%d_%f_%f %f %f\n", rank,node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1] ,node->split->kd_coord[0], node->split->kd_coord[1]);
    return;
  }
  if(node->kid) {
    if(node->split && node->kid->split) {
      printf("C) %d %3d P%d_%f_%f %f %f\n", rank,node->level, rank,node->split->kd_coord[0], node->split->kd_coord[1],node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) %d %3d P%d_%f_%f P%d_%f_%f\n", rank,node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1] , rank , node->kid->split->kd_coord[0], node->kid->split->kd_coord[1]);
    }
    print_tree_A2A(node->kid);
  }
  else {
    if (node->left) {
      printf("C) %d %3d P%d_%f_%f %f %f\n", rank,node->level, rank,node->split->kd_coord[0], node->split->kd_coord[1],node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) %d %3d P%d_%f_%f P%d_%f_%f\n", rank,node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1] , rank , node->left->split->kd_coord[0], node->left->split->kd_coord[1]);
      print_tree_A2A(node->left);
    }
    
    if (node->right) {
      printf("C) %d %3d P%d_%f_%f %f %f\n", rank, node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1],node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) %d %3d P%d_%f_%f P%d_%f_%f\n", rank,node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1] , rank , node->right->split->kd_coord[0], node->right->split->kd_coord[1]);
      print_tree_A2A(node->right);
    }
  }
}


void debug_tree_A2A(const struct kd_node_t *node)
/*
 * Function to visualize the tree generated by node, mainly for debugging/checking
 */
{
  if(node==NULL) {return;}
  int rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  if(node->kid==NULL && node->left==NULL && node->right==NULL) {
    printf("{%d}[%d] (%.3f,%.3f) -> NULL \n", node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1] );
    return;
  }
  if(node->kid) {
    if(node->split && node->kid->split) {
      printf("{%d}[%d] (%.3f,%.3f) -> (%.3f,%.3f) \n",
	     node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1],
	     node->kid->split->kd_coord[0], node->kid->split->kd_coord[1]);
    }
    debug_tree_A2A(node->kid);
  }
  else {
    if (node->left) {
      printf("{%d}[%d] (%.3f,%.3f) -> (%.3f,%.3f)  \n",
	     node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1],
	     node->left->split->kd_coord[0], node->left->split->kd_coord[1]);
      debug_tree_A2A(node->left);
    }
    
    if (node->right) {
      printf("{%d}[%d] (%.3f,%.3f) -> (%.3f,%.3f) \n",
	     node->level, rank, node->split->kd_coord[0], node->split->kd_coord[1],
	     node->right->split->kd_coord[0], node->right->split->kd_coord[1]);
      debug_tree_A2A(node->right);
    }
  }
}


void load_from_file_distributed_A2A( int argc,  char ** argv, int *N_ptr, int *N_glo_ptr,  const int ndim, struct kd_point_t ** points_ptr, const int N_p, const int rank)
{
  
  if(argc != 2) {
    if(rank==0)
      printf( "usage: %s filename\n", argv[0] );
    exit (EXIT_FAILURE);
  }
  MPI_Datatype MPI_kd_point, tmp_type;
  int array_of_blocklengths[] = {NDIM};
  MPI_Aint array_of_displacements[] = {0};
  MPI_Datatype array_of_types[] = {MPI_float_t};
  MPI_Aint lb, extent;
  MPI_Type_create_struct(1, array_of_blocklengths, array_of_displacements, array_of_types, &tmp_type);
  MPI_Type_get_extent(tmp_type, &lb, &extent);
  MPI_Type_create_resized(tmp_type, lb, extent, &MPI_kd_point);
  MPI_Type_commit(&MPI_kd_point);
  MPI_Status status;
  int tag = 0;
  FILE *fptr;
  fptr=NULL;
  if(rank==0) {
    fptr = fopen(argv[1],"r");
    if(fptr == NULL) {
      fprintf(stderr, "%s", "Error occurred while opening file!\n");
      MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);
      exit(1);
    }
    printf("MPI kd-tree\n");
    printf("Loadind data from file: %s\n", argv[1]);
    fscanf(fptr,"%d", N_glo_ptr);
    (*N_ptr) = (*N_glo_ptr) / N_p;
  }
  MPI_Bcast(N_ptr, 1, MPI_INT, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if(rank==0) {
    struct kd_point_t one_point;
    for (int n=1; n < N_p; ++n) {
      (*points_ptr)= (struct kd_point_t *) malloc((*N_ptr)*sizeof(struct kd_point_t));
      for (int i = 0; i < (*N_ptr) ; ++i) {
	for(int d = 0; d < ndim; d++) {
#if defined(DOUBLE_PRECISION)
          fscanf(fptr,"%lf", &one_point.kd_coord[d]);
#else
          fscanf(fptr,"%f", &one_point.kd_coord[d]);
#endif
	}
	(*points_ptr)[i] = one_point;
      }
      MPI_Ssend((*points_ptr), (*N_ptr), MPI_kd_point, n, tag, MPI_COMM_WORLD);
      free((*points_ptr));
    }
  }
  else {
    (*points_ptr) = (struct kd_point_t *) malloc((*N_ptr)*sizeof(struct kd_point_t));
    MPI_Recv((*points_ptr), (*N_ptr), MPI_kd_point, 0, tag, MPI_COMM_WORLD, &status);
  }
  MPI_Barrier(MPI_COMM_WORLD);
  if(rank==0) {
    struct kd_point_t one_point;
    (*points_ptr)= (struct kd_point_t *) malloc((*N_ptr)*sizeof(struct kd_point_t));
    for (int i = 0; i < (*N_ptr) ; ++i) {
      for(int d = 0; d< ndim; d++) {
#if defined(DOUBLE_PRECISION)
        fscanf(fptr,"%lf", &one_point.kd_coord[d]);
#else
        fscanf(fptr,"%f", &one_point.kd_coord[d]);
#endif
      }
      (*points_ptr)[i] = one_point;
    }
    fclose(fptr);
  }
  MPI_Type_free(&MPI_kd_point);
  MPI_Type_free(&tmp_type);  
}



void generate_random_points_distributed_A2A( int argc,  char ** argv, int *N_ptr, int *N_glo_ptr, const int ndim, struct kd_point_t ** points_ptr, const int N_p, const  int rank)
{
  srand48(SEED*(rank+100)) ;
  if(argc != 2) {
    if(rank==0)
      printf( "usage: %s N\n", argv[0] );
    exit (EXIT_FAILURE);
  }
  if(argc==2)
    (*N_glo_ptr)=atoi(argv[1]);
  (*N_ptr) = (*N_glo_ptr)/N_p;
  if(rank==0) {
    printf("MPI kd-tree\n");
    printf("Generating %d random double in [0,1]\n", (*N_glo_ptr));
  }
  (*points_ptr) = (struct kd_point_t*) malloc( (*N_ptr) * sizeof(struct kd_point_t));
  for (int i = 0; i < (*N_ptr); i++) {
    for (int j = 0; j < ndim; j++)
      (*points_ptr)[i].kd_coord[j]=drand48();
  }  
}

