#if !defined(DOUBLE_PRECISION)
#define MPI_float_t MPI_FLOAT
#else
#define MPI_float_t MPI_DOUBLE
#endif
#define MIN_NUM_OF_POINTS 4
#define MAX_MPI_LEVEL 5
#define SEED 1234567

bool IsPowerOfTwo(int x);
/*
 * Check if x is a power of 2
 */

void glb_mean(// input
              const kd_point *points,
              const int numof_points,
              const int glb_numof_points,
              const int axis,
              MPI_Comm comm,
              // output
              float_t *glb_mu);
/*
 * glb_mean returns the global mean (glb_mu) of the points in the MPI Communicator comm
 * according to the coordinate specified by axis.
 * numof_points are the number of points that belong to the process
 * glb_numof_points are the number of points that belong to all tha process in comm
 */


void find_median(// input
                 const kd_point * arr,
                 const int N,
                 const int ks,
                 const int axis,
                 MPI_Comm comm,
                 // output
                 float_t * median);
/*
 * find_median returns find the ks-th smallest element,
 * according to the direction specified by axis,
 * among all the points in the MPI Communicator comm.
 * Each process passes to find_median its own N points in the array of points arr.
 * To get the median call find_median with ks = glb_N/2
 * where glb_N is the total number of points in comm
 * Basically a parallel quick select
 */

void Pointwise_exchange(// input:
                        kd_point * X_l, const int N_l,
                        kd_point * X_r, const  int N_r,
                        int ndim,
                        MPI_Comm comm,
                        // output:
                        kd_point ** X_n,
                        int * N_n);
/*
 * Given a left array of points N_l with N_l points and
 * Given a right array of points N_r with N_r points
 * Given a pointer X_n to an array to be resized and modified
 * this function finds a companion patner and performs points exchange
 * modifying the X_n assigning to it N_n points
 */


void show_array_P2P(const kd_point *data,
                    const int start,
                    const int end,
                    const int level,
                    const char c);
/*
 * Function to print the points in data from start to end,
 * according to the level in the tree
 */

void build_kdtree_distributed_P2P(struct kd_node_t * node, struct kd_point_t **points_ptr, const int N, const int ndim, const int axis,const int level, MPI_Comm comm);




void print_tree_P2P(const struct kd_node_t *node);
/*
 * Function to visualize the tree generated by node, mainly for debugging/checking
 */

void debug_tree_P2P(const struct kd_node_t *node);
/*
 * Function to visualize the tree generated by node, mainly for debugging/checking
 */


void clear_P2P(struct kd_node_t *root);
/*
 * This function frees the nodes of the tree
 */

void load_from_file_distributed_P2P ( int argc,  char ** argv, int *N_ptr, int *N_glo_ptr, const int ndim, struct kd_point_t ** points_ptr, const int N_p, const int rank);


void generate_random_points_distributed_P2P ( int argc,  char ** argv, int *N_ptr, int *N_glo_ptr, const int ndim, struct kd_point_t ** points_ptr, const int N_p, const  int rank);
