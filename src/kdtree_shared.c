#if defined(__STDC__)
#  if (__STDC_VERSION__ >= 199901L)
#     define _XOPEN_SOURCE 700
#  endif
#endif

#include <kdtree_shared.h>
#define SEED 1234567

// Adapted from https://rosettacode.org/wiki/Quickselect_algorithm#C
struct kd_point_t * quickselect( struct kd_point_t * arr, const int N, const int ks, const int axis)
/*
 * Serial quickselect according for the array of points arr
 * whose dimension is N with respect to the direction specified by axis
 * It returns the ks-th smallest point, it also partially sorts the data.
 */
{
  int i, st;
  for (st = i = 0; i < N - 1; i++) {
    if (arr[i].kd_coord[axis] > arr[N-1].kd_coord[axis])
      continue;
    swap(arr + i, arr + st );
    st++;
  }
  swap( arr + N - 1 , arr + st );
  return ks == st? arr + st : ( st > ks? quickselect( arr , st, ks, axis) : quickselect( arr + st, N - st, ks - st, axis) );
}

void show_array_shared(const kd_point *data, const int start, const int end, const int level, const char c)
/*
 * Debugging function to print the array
 */
{
  for ( int i = start; i < end; i++ )
    printf( "p:[%d](%c){0} [%.3f, %.3f],\n", level, c, data[i].kd_coord[0] ,data[i].kd_coord[1] );
  printf("\n");
}


void build_kdtree_serial(struct kd_node_t * node, struct kd_point_t *points,const int N, const int ndim, const int axis, const int level)
{
  // Just to be sure, we set the MPI parallel kid to NULL,
  // here we just have serial left and right child
  node->kid = NULL;
  // Something went wrong if N==0
  if (N<1) {
    fprintf(stderr, "%s", "Error N<1!\n");
    return;
  }
  
  // axis is the splitting dimension from the previous call
  int myaxis = choose_splitting_dimension (ndim, axis);
  // level is the level of depth from the previous call
  int mylevel = level + 1;
  node->axis = myaxis;
  node->level = mylevel;
  
  // If N==1, save the leaf node and return
  if (N==1) {
    node->split =  points ;
    node->left=NULL;
    node->right=NULL;
    return ;
  }
  
  // Look for the splitting point
  struct kd_point_t * splitting_point;
  splitting_point = quickselect(points, N, N/2, myaxis);
  // If we have found it...
  if (splitting_point) {
    // Save the splitting point in node
    node->split = splitting_point;
    // Find left and right points
    struct kd_point_t * left_points, * right_points;
    left_points = points;
    right_points = splitting_point + 1;
    int N_left, N_right;
    N_left = splitting_point - points;
    N_right = points + N - (splitting_point + 1);
    // Recursively build the tree
    if(N_left) {
      node->left = (struct kd_node_t*) malloc (sizeof(struct kd_node_t));
      build_kdtree_serial(node->left, left_points, N_left, ndim, myaxis, mylevel );
    }
    else node->left=NULL;
    
    if(N_right) {
      node->right = (struct kd_node_t*) malloc (sizeof(struct kd_node_t));
      build_kdtree_serial(node->right, right_points, N_right, ndim, myaxis, mylevel);
    }
    else node->right=NULL;
  }
  return;
}


void clear_shared(struct kd_node_t *root)
/*
 * This function frees the nodes of the tree
 */
{
  if(root==NULL)
    return;
  if(root->kid) {
    // Note here!!
    // If we are in the P2P parallel region, we have mallocated the node->split
    if(root->split)
      free(root->split);
    clear_shared(root->kid);
  }
  else {
    clear_shared(root->left);
    clear_shared(root->right);
  }
  free(root);
}


void print_tree_shared(const struct kd_node_t *node)
/*
 * Function to visualize the tree generated by node
 */
{
  if(node==NULL) {return;}
  
  if(node->kid==NULL && node->left==NULL && node->right==NULL) {
    printf("C) 0 %3d P0_%f_%f %f %f\n",node->level, node->split->kd_coord[0], node->split->kd_coord[1] ,node->split->kd_coord[0], node->split->kd_coord[1]);
    return;
  }
  if(node->kid) {
    if(node->split && node->kid->split) {
      printf("C) 0 %3d P0_%f_%f %f %f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1], node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) 0 %3d P0_%f_%f P0_%f_%f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1], node->kid->split->kd_coord[0], node->kid->split->kd_coord[1]);
    }
    print_tree_shared(node->kid);
  }
  else {
    if (node->left) {
      printf("C) 0 %3d P0_%f_%f %f %f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1],node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) 0 %3d P0_%f_%f P0_%f_%f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1] , node->left->split->kd_coord[0], node->left->split->kd_coord[1]);
      print_tree_shared(node->left);
    }
    
    if (node->right) {
      printf("C) 0 %3d P0_%f_%f %f %f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1], node->split->kd_coord[0], node->split->kd_coord[1] );
      printf("D) 0 %3d P0_%f_%f P0_%f_%f\n", node->level, node->split->kd_coord[0], node->split->kd_coord[1], node->right->split->kd_coord[0], node->right->split->kd_coord[1]);
      print_tree_shared(node->right);
    }
  }
}



void debug_tree_shared(const struct kd_node_t *node)
/*
 * Function to visualize the tree generated by node
 */
{
  if(node==NULL) {return;}
  if(node->kid==NULL && node->left==NULL && node->right==NULL) {
    printf("{%d}[0] (%.3f,%.3f) -> NULL \n",
	   node->level, node->split->kd_coord[0], node->split->kd_coord[1] );
    return;
  }
  if(node->kid) {
    if(node->split && node->kid->split)
      printf("{%d}[0] (%.3f,%.3f) -> (%.3f,%.3f) \n",
	     node->level,  node->split->kd_coord[0], node->split->kd_coord[1],
	     node->kid->split->kd_coord[0], node->kid->split->kd_coord[1]);
    debug_tree_shared(node->kid);
  }
  else {
    if (node->left) {
      printf("{%d}[0] (%.3f,%.3f) -> (%.3f,%.3f)  \n",
	     node->level,  node->split->kd_coord[0], node->split->kd_coord[1],
	     node->left->split->kd_coord[0], node->left->split->kd_coord[1]);
      debug_tree_shared(node->left);
    }
    
    if (node->right) {
      printf("{%d}[0] (%.3f,%.3f) -> (%.3f,%.3f) \n",
	     node->level, node->split->kd_coord[0], node->split->kd_coord[1],
	     node->right->split->kd_coord[0], node->right->split->kd_coord[1]);
      debug_tree_shared(node->right);
    }
  }
}



void generate_random_points_shared(int argc,char ** argv, int *N_ptr, const int  ndim, struct kd_point_t ** points_ptr)
{
  if(argc != 2) {
    printf( "usage: %s N\n", argv[0] );
    exit(1);
  }
  
  (*N_ptr)=atoi(argv[1]);
  printf("Shared kd-tree\n");
  srand48 ( SEED ) ; // seed the number generator
  printf("Generating %d random double in [0,1]\n", (*N_ptr));
  (*points_ptr) = (struct kd_point_t*) malloc ((*N_ptr)*sizeof(struct kd_point_t));
  for (int i = 0; i < (*N_ptr); i++) {
    for (int j = 0; j < ndim; j++)
      (*points_ptr)[i].kd_coord[j]=drand48();
  }
}



void load_from_file_shared(int argc,char ** argv, int *N_ptr, const int  ndim, struct kd_point_t ** points_ptr)
{
  if(argc != 2) {
    printf( "usage: %s filename\n", argv[0] );
    exit(1);
  }
  FILE *fptr;
  fptr = fopen(argv[1],"r");
  if(fptr == NULL) {
    printf("Error! opening file\n");
    exit(2);
  }
  printf("Shared kd-tree\n");
  printf("Loadind data from file: %s\n", argv[1]);
  fscanf(fptr,"%d", N_ptr);
  struct kd_point_t one_point;
  (*points_ptr) = (struct kd_point_t *) malloc((*N_ptr)*sizeof(struct kd_point_t));
  for (int i = 0; i < (*N_ptr); ++i) {
    for(int d = 0; d< ndim; d++) {
#if defined(DOUBLE_PRECISION)
      fscanf(fptr,"%lf", &one_point.kd_coord[d]);
#else
      fscanf(fptr,"%f", &one_point.kd_coord[d]);
#endif
    }
    (*points_ptr)[i] = one_point;
  }
  fclose(fptr);
}




#if defined _OPENMP

void build_kdtree_shared(struct kd_node_t * node, struct kd_point_t *points, int N, int ndim, int axis, int level, int threadsLeft)
/*
 * points is a pointer to the relevant section of the data set;
 * N is the number of points to be considered, from points to points+N
 * ndim is the number of dimensions of the data points
 * axis is the dimension used previouly as the splitting one
 * level is the previouly level of depths
 * threadsLeft is the number of threads available
 */
{
  node->kid = NULL;
  
  if (N<1) {
    fprintf(stderr, "%s", "Error: N<1!\n");
    return;
  }
  
  // axis is the splitting dimension from the previous call
  int myaxis = choose_splitting_dimension (ndim, axis);
  // level is the level of depth from the previous call
  int mylevel = level + 1;
  node->axis = myaxis;
  node->level = mylevel;
  
  // printf("level=%d, threadsLeft=%d\n", mylevel, threadsLeft);
  // If N==1, save the leaf node and return
  if (N==1) {
    node->split= points ;
    node->right= NULL;
    node->left = NULL;
    return ;
  }
  
  if(threadsLeft<=1 )
    return build_kdtree_serial(node, points,  N,  ndim, axis, level);
  
  struct kd_point_t * splitting_point;
  splitting_point = quickselect(points, N, N/2, myaxis);
  if (splitting_point) {
    node->split = splitting_point;
    struct kd_point_t * left_points, * right_points;
    left_points = points;
    right_points = splitting_point + 1;
    int N_left, N_right;
    N_left = splitting_point - left_points;
    N_right = points + N - right_points;
    
    if(N_left) {
#pragma omp task
      {
	node->left = (struct kd_node_t*) malloc (sizeof(struct kd_node_t));
	build_kdtree_shared(node->left, left_points, N_left, ndim, myaxis, mylevel,threadsLeft/2);
      }
    }
    else node->left=NULL;
    
    if(N_right) {
#pragma omp task
      {
	node->right = (struct kd_node_t*) malloc (sizeof(struct kd_node_t));
	build_kdtree_shared(node->right, right_points, N_right, ndim, myaxis, mylevel,threadsLeft-threadsLeft/2);
      }
    }
    else node->right=NULL;
#pragma omp taskwait
  }
  return;
}
#endif
